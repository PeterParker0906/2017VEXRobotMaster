#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    line1,          sensorLineFollower)
#pragma config(Sensor, in2,    line2,          sensorLineFollower)
#pragma config(Sensor, in3,    degree1,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, dgtl3,  leftHand,       sensorTouch)
#pragma config(Sensor, dgtl4,  rightHand,      sensorTouch)
#pragma config(Sensor, dgtl6,  backTouch,      sensorTouch)
#pragma config(Sensor, I2C_1,  L,              sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  R,              sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           left,          tmotorVex393_HBridge, openLoop, reversed, driveLeft, encoderPort, I2C_1)
#pragma config(Motor,  port4,           hand1,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           hand2,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           arm1,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           arm2,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          right,         tmotorVex393_HBridge, openLoop, driveRight, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int a[]={1,1,1,1};
float markDistanceM=20;
int armPlace;
int lineVule=985;
bool passLine;
void move(int Speed,int times);
void init();
void turn(int Speed,int times);
void riseArm(int Speed,int riseDegree);
void openClam();
void closeClam();
int findLine();
bool distentFind(float markDistance);
void lineFollow(int speed);
void startAction();
void getStar();
void initAll();

int shortTurn=133;
int shortTurnSpeed=-127;
int longTurn=400;
int longTurnSpeed=127;

int armPlace1=2399;
int armPlace2=2680;
int armPlace3=4095;

task main()
{
	while(true){
	  // This is the main execution loop for the user control program. Each time through the loop
	  // your program should update motor + servo values based on feedback from the joysticks.

	  // .....................................................................................
	  // Insert user code here. This is where you use the joystick values to update your motors, etc.
	  // .....................................................................................

		if(vexRT[Btn6D]==1)closeClam();
		else if(vexRT[Btn6U]==1)openClam();
		else if(vexRT[Btn5U]==1)riseArm(127,armPlace3);
		else if(vexRT[Btn5D]==1)riseArm(127,armPlace1);
	  //UserControlCodePlaceholderForTesting(); // Remove this function call once you have "real" code.
	  motor[left]  = (vexRT[Ch2] + vexRT[Ch1])/2;  // (y + x)/2
		motor[right] = (vexRT[Ch2] - vexRT[Ch1])/2;  // (y - x)/2						// Remove these as well and replace with your appropriate code
	}
	//int r;int l;
	//turn(shortTurnSpeed,shortTurn);
	///riseArm(127,armPlace2);

	//closeClam();
	//delay(6000)
	//openClam();
	//while(true){float a=SensorValue(degree1)}
//while(true){
		//turn(shortTurnSpeed,shortTurn);
		//float a=SensorValue(degree1);
//		r=getMotorEncoder(right);
//		l=getMotorEncoder(left);
//	}
		/*startAction();
		/*******************************
		bool findLineM=false;
		while(!passLine){
			if(findLine()==0){
				move(60,10);
				if(findLineM)passLine=true;
			}
			else if(findLine()==1){
				turn(60,30);
			}
			else if(findLine()==2){
				turn(60,30);
			}
			else if(findLine()==3){
				turn(90,50);
				findLineM=true;
			}
		}
		/********************************
		openClam();
		while(true){
			move(127,10);
			if(distentFind(markDistanceM)){
				closeClam();
				riseArm(60,2400);
				turn(90,50);
				move(-60,100);
				riseArm(60,3000);
				openClam();
				riseArm(60,1000);
				move(60,100);
				turn(-90,50);
				riseArm(60,1000);
				break;
			}
		}
		/********************************
		while(true){
			lineFollow(100);
			if(SensorValue(backTouch)==0)break;
		}
		for(int i=0;i<4;i++){
			move(127,a[i]);
			getStar();
		}

		while(true){
		int value1=SensorValue(line1);
		int value2=SensorValue(line1);
		move(70,13);
		turn(80,3);
		move(70,13);
		}*/


}

void startAction(){
	initAll();
	riseArm(127,armPlace3);
	closeClam();
	openClam();
	riseArm(127,armPlace1);

}
void init(){
	resetMotorEncoder(right);
  resetMotorEncoder(left);
}
void initAll(){
		resetMotorEncoder(right);
    resetMotorEncoder(left);
    passLine=false;
    armPlace=SensorValue(degree1);
}

void lineFollow(int speed){
	if(findLine()==0){
		move(speed,10);
	}
	else if(findLine()==1){
		turn(shortTurnSpeed,shortTurn);
	}
	else if(findLine()==2){
		turn(-shortTurnSpeed,shortTurn);
	}
	else if(findLine()==3){
		turn(longTurnSpeed,longTurn);
	}

}

void getStar(){
	turn(longTurnSpeed,longTurn);
	openClam();
	move(60,100);
	closeClam();
	riseArm(60,armPlace2);
	move(-60,200);
	riseArm(60,armPlace3);
	openClam();
	riseArm(60,armPlace1);
	move(60,100);
	turn(-longTurnSpeed,longTurn);
}

void move(int Speed,int times){
	int counter=0;
	int rightCounter;
	int leftCounter;
	while(counter< times)
  {
		motor[left]=Speed;
		motor[right]=Speed;
		rightCounter=getMotorEncoder(right);
		leftCounter=getMotorEncoder(left);
		counter=(rightCounter+leftCounter)/2;
	}
		motor[left]=0;
		motor[right]=0;
		delay(10);
		init();
}

void turn(int Speed,int times){
	int counter=0;
	while(counter< times)
  {
		motor[left]=-Speed;
		motor[right]=Speed;
		int rightCounter=getMotorEncoder(right);
		int leftCounter=getMotorEncoder(left);
		if(Speed>0)counter=getMotorEncoder(right);
		else counter=getMotorEncoder(left);
	}
		motor[left]=0;
		motor[right]=0;
		delay(10);
		init();
}

void closeClam(){
		motor[hand1]=-127;
		motor[hand2]=-127;
}

void openClam(){
		motor[hand1]=127;
		motor[hand2]=127;
		delay(10);
		motor[hand1]=0;
		motor[hand2]=0;
}

void riseArm(int Speed,int riseDegree){
	if(armPlace>riseDegree){
		while(armPlace> riseDegree)
 	 	{
	  	motor[arm1]=-Speed;
			motor[arm2]=-Speed;
			armPlace=SensorValue(degree1);
		}
	}
	else{
		while(armPlace< riseDegree)
 	 	{
	  	motor[arm1]=Speed;
			motor[arm2]=Speed;
			armPlace=SensorValue(degree1);
		}
	}
	 	motor[arm1]=0;
		motor[arm2]=0;
		delay(10);
}
int findLine(){
	int valueL=SensorValue(line1);
	int valueR=SensorValue(line2);
	//lineVule=valueR;
	if(valueL>=lineVule&&valueR>=lineVule){
		return 0;
	}else if(valueL>=lineVule&&valueR<lineVule){//Right have white
		return 1;
	}
	else if(valueR>=lineVule&&valueL<lineVule){//Left have white
		return 2;
	}
	else if(valueR<lineVule&&valueL<lineVule){
		return 3;
	}
	return -1;
}

bool distentFind(float markDistance){
	if(markDistance>SensorValue(sonarSensor)){
		return true;
	}
	return false;
}
